---
title: "Transcriptomics. RNA-seq data analysis"
author: "Leonardo Claudin"
date: "25/2/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library("tidyverse")
library(dplyr)
library(plyr)
library("gridExtra")
library(DESeq2)
library(rlist)
library(logr)
library(broom)
library(cowplot)
library(ggrepel)
library(clusterProfiler)
library(qvalue)
library(apeglm)
library(ashr)
library(gage)
# Load project settings
# you will need to have the "here" package installed in your computer
# run install.packages("here") if you don't have it
source(here::here("settings.R"))
# Load helper functions
source(file.path(functions.dir, "output.R"))
# load transcriptomics count data
df.transcriptomics.design <- read_output_csv("transcriptomics_design", .output.dir = data.dir)
df.counts.raw <- read_output_csv("raw_counts_transcriptomics", .output.dir = data.dir)
df.gene.id <- read_output_csv("gene_id_matching", .output.dir = data.dir)
df.proteomics <- read_output_csv("proteomics",.output.dir = data.dir)
df.go.terms <- read_output_csv("go_terms", .output.dir = data.dir)
```

# Working with Raw Data.
## Study the percentage of Non-Coding sequences.

```{r}
df.counts.raw.non.cds = df.counts.raw %>% filter(str_detect(gene, "_"))
df.sum.counts.raw = aggregate(df.counts.raw$counts,
                           by = list(sequence_id = df.counts.raw$sequence_id),
                           FUN = sum)
df.counts.raw.non.cds = left_join(df.counts.raw.non.cds, df.sum.counts.raw, by = "sequence_id")
df.counts.raw.non.cds$rel_counts = df.counts.raw.non.cds$counts/df.counts.raw.non.cds$x
```

```{r}
ggplot(df.counts.raw.non.cds, aes(x = as.factor(gene), y = as.numeric(rel_counts))) +
  geom_col(width = 0.7) +
  facet_wrap(~sequence_id) +
  scale_y_continuous(labels = scales::percent, limits=c(0,1)) +
  coord_flip() +
  labs(y = "Percentage of total counts (%)", x = "Type of NON-CDS",
       title = "Percentage of total counts not assigned to CDS", 
       subtitle = "These account for rRNA")
```

## Removing rows with NON-CDS information.

```{r}
df.counts.cds  = df.counts.raw %>% filter(! str_detect(gene, "_"))
```

## Removing rows with low count.

```{r}
df.counts.low = df.counts.cds %>% filter(counts <= 24)
df.counts.low = as.data.frame(table(df.counts.low$gene))
df.counts.low = df.counts.low %>% filter(Freq == 6)
df.counts.fil = df.counts.cds %>% filter(! gene %in% df.counts.low$Var1)
#df.counts.zero = df.counts.fil %>% filter(counts == 0)
#df.counts.fil = df.counts.fil %>% filter(! gene %in% df.counts.zero$gene)
df.sum.counts.fil = aggregate(df.counts.fil$counts,
                           by = list(sequence_id = df.counts.fil$sequence_id),
                            FUN = sum)
df.sum.counts.fil$src = "After filtering"
df.sum.counts.raw$src = "Before filtering"
df.sum.counts.plot = rbind(df.sum.counts.fil, df.sum.counts.raw)
colnames(df.sum.counts.plot) = c("sequence_id", "total_counts", "source")
```

```{r}
ggplot(df.sum.counts.plot, aes(x = as.factor(sequence_id), y = total_counts/10^6, fill = source)) +
  geom_col(width = 0.7, position = position_dodge()) +
  labs(y = "Total Million counts", x = "sequence_id",
       title = "Filtering out genes with low count",
       subtitle = "Genes with counts < 24 on every sample filtered out") +
  guides(fill = guide_legend(title = "Dataset")) 
```

## Normalization of raw counts.

```{r}
A = ggplot(df.counts.fil, 
           aes(x = as.factor(sequence_id), y = log2(counts), color = sequence_id)) +
      geom_boxplot() +
      labs(x = "Sequence ID", y = "Gene expression (log2(counts))",
           title = "Gene expression per sequence") +
      theme_bw() +
      theme(legend.position = "null")

B = ggplot(df.counts.fil, aes(x = log2(counts), colour = sequence_id)) +
      geom_density() +
      labs(x = "Gene expression (log2(counts))", 
           title = "Density curve of Gene expression") +
      theme_bw() +
      theme(legend.position = "null")
grid.arrange(A, B, ncol = 2, nrow = 1)
```

### Normalization using DESeq2.

```{r}
counts = dlply(df.counts.fil, "sequence_id", function(df){
  as.integer(df$counts)
})
countData = list.cbind(counts)
df.design = df.transcriptomics.design[,2:3]
dds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = df.design,
                              design =  ~ purpose)
dds <- estimateSizeFactors(dds)
countData.norm.DESeq2 = counts(dds, normalized=TRUE)
```

```{r}
df.norm.counts.DESeq2 = as.data.frame(stack(countData.norm.DESeq2)[,-1])
colnames(df.norm.counts.DESeq2) = c("sequence_id", "counts")
df.norm.counts.DESeq2$gene = df.counts.fil$gene
```

```{r}
A = ggplot(df.norm.counts.DESeq2, 
           aes(x = as.factor(sequence_id), y = log2(counts), color = sequence_id)) +
      geom_boxplot() +
      labs(x = "Sequence ID", y = "Gene expression (log2(counts))",
           title = "Gene expression per sequence") +
      theme_bw() +
      theme(legend.position = "null")

B = ggplot(df.norm.counts.DESeq2, aes(x = log2(counts), colour = sequence_id)) +
      geom_density() +
      labs(x = "Gene expression (log2(counts))", 
           title = "Density curve of Gene expression") +
      theme_bw() +
      theme(legend.position = "null")
grid.arrange(A, B, ncol = 2, nrow = 1)
```

### Normalization using Size Factors.

```{r}
df.norm.counts.SF = ddply(df.counts.fil, .(gene), transform, pseudo_reference = exp(mean(log(counts))))
df.norm.counts.SF$ratio = df.norm.counts.SF$counts/df.norm.counts.SF$pseudo_reference
df.norm.counts.SF = ddply(df.norm.counts.SF, .(sequence_id), transform, size_factor = median(ratio, na.rm = T))
df.norm.counts.SF$normalized_count = df.norm.counts.SF$counts/df.norm.counts.SF$size_factor
```

```{r}
A = ggplot(df.norm.counts.SF, 
           aes(x = as.factor(sequence_id), y = log2(normalized_count), color = sequence_id)) +
      geom_boxplot() +
      labs(x = "Sequence ID", y = "Gene expression (log2(counts))",
           title = "Gene expression per sequence") +
      theme_bw() +
      theme(legend.position = "null")

B = ggplot(df.norm.counts.SF, aes(x = log2(normalized_count), colour = sequence_id)) +
      geom_density() +
      labs(x = "Gene expression (log2(counts))", 
           title = "Density curve of Gene expression") +
      theme_bw() +
      theme(legend.position = "null")
grid.arrange(A, B, ncol = 2, nrow = 1)
```

### Quality control: PCA on DESeq2.

```{r}
df.pca.DESeq2 <- df.norm.counts.DESeq2 %>% 
  mutate(
    log_counts = log2(counts + 1)
  ) %>% 
  left_join(df.transcriptomics.design, by = "sequence_id") %>% 
  select(-counts) %>% 
  pivot_wider(values_from = log_counts, 
              names_from = gene
  ) %>% 
  mutate(
    channel = as.character(channel)
  )
```

```{r}
pca_fit <- df.pca.DESeq2 %>% 
  select(where(is.numeric)) %>% # retain only numeric columns
  prcomp(scale = F, center = TRUE) # do PCA on scaled data
```

```{r}
pca_fit %>%
  augment(df.pca.DESeq2) %>% # add original dataset back in
  ggplot(aes(.fittedPC1, .fittedPC2, color = purpose, label = channel)) + 
  geom_text() + geom_point(shape = 22, size = 4, alpha = 0.5) +
  scale_color_manual(
    values = c(control = "#00BBDB", treatment = "#F066EA")
  ) + theme_bw() +
  labs(x = "PC1", y = "PC2") +
  guides(color=guide_legend(title="Purpose"))
```

```{r}
pca_fit %>%
  augment(df.pca.DESeq2) %>% # add original dataset back in
  ggplot(aes(.fittedPC2, .fittedPC3, color = purpose, label = channel)) + 
  geom_text() + geom_point(shape = 22, size = 4, alpha = 0.5) +
  scale_color_manual(
    values = c(control = "#00BBDB", treatment = "#F066EA")
  ) + theme_bw() +
  labs(x = "PC2", y = "PC37") +
  guides(color=guide_legend(title="Purpose"))
```

```{r}
var.pca = as.data.frame(t(summary(pca_fit)$importance))
colnames(var.pca) = c("sd", "variance", "cumvar")
var.pca$npc = as.character(seq(from = 1, to = 6, by = 1))
```

```{r}
ggplot(var.pca, aes(x = npc, y = variance, group = 1)) +
  geom_col(fill = "#00BBDB", alpha = 0.5) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0,1), labels = scales::percent) +
  labs(x = "PC", y = "Explained variance (%)") +
  theme_bw()
```

```{r}
ggplot(var.pca, aes(x = npc, y = cumvar, group = 1)) +
  geom_col(fill = "#00BBDB", alpha = 0.5) + 
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0,1), labels = scales::percent) +
  labs(x = "PC", y = "Cumulative variance (%)") +
  theme_bw()
```

```{r}
fviz_pca_ind(pca_fit,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
```

```{r}
# define arrow style for plotting
arrow_style <- arrow(
  angle = 10, ends = "first", type = "closed", length = grid::unit(5, "pt")
)

# plot rotation matrix
pca_fit %>%
  tidy(matrix = "rotation") %>%
  pivot_wider(names_from = "PC", names_prefix = "PC", values_from = "value") %>%
  filter(!between(dense_rank(PC1), 10, n() - 10)) %>%
  dplyr::rename(ncbi_id = column) %>%
  left_join(df.gene.id[,1:2], by = "ncbi_id") %>%
  ggplot() +
  geom_segment(aes(PC1, PC2), 
               xend = 0, yend = 0, arrow = arrow_style, alpha = 0.4) +
  geom_text_repel(
    aes(PC1, PC2,label = gene_name), 
    color = "darkred") + theme_bw()
```

## Finding DGEs.

```{r}
df.dge.DESeq2 = df.norm.counts.DESeq2 %>% 
  mutate(logcounts = counts) %>% 
  select(-counts) %>%
  pivot_wider(values_from = logcounts,
               names_from = sequence_id)
dds.dge <- DESeqDataSetFromMatrix(countData = round(df.dge.DESeq2[,2:7]),
                              colData = df.design,
                              design =  ~ purpose)
```

```{r}
dge.res = DESeq(dds.dge)
res.dge = results(dge.res)

df.dge.fit = df.dge.DESeq2 %>%
  mutate(log.pvalue = -log10(res.dge$pvalue),
         fold.change = res.dge$log2FoldChange,
         pvalue=res.dge$pvalue,
         qvalue=qvalue(res.dge$pvalue)$qvalue) %>%
    dplyr::rename(ncbi_id = gene) %>%
  left_join(df.gene.id, by = "ncbi_id") %>% 
  mutate(
    color = ifelse((log.pvalue>-log10(0.01)& 
                      abs(fold.change)>log2(2)), "darkred", "lightblue"))
```

```{r}
df.dge.fit %>%
  mutate(gene_name = ifelse(color == "darkred", gene_name, NA)) %>%
  ggplot(aes(x = fold.change, y = log.pvalue, color = color, label = gene_name)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.01)) +
  geom_vline(xintercept = log2(2)) +
  geom_vline(xintercept = -log2(2)) +
  theme_bw() +
  geom_text_repel() +
  labs(x = "Effect size: log2(fold-change)", 
       y = "-log10(adjusted p-value)",
       title = "Volcano Plot") +
  theme(legend.position = "none")
```

### Wald Test

```{r}
#https://hbctraining.github.io/DGE_workshop_salmon_online/lessons/05b_wald_test_results.html
resultsNames(dge.res) # to see what names to use
contrast <- list(resultsNames(dge.res)[1], resultsNames(dge.res)[2])
results(dge.res, contrast = contrast)

contrast_oe <- c("purpose", "treatment", "control")

res_tableOE <- results(dge.res, contrast=contrast_oe, alpha = 0.05)
res_tableOE_normal <- lfcShrink(dge.res, 
                                coef="purpose_treatment_vs_control", 
                                type="normal", 
                                lfcThreshold=1)
res_tableOE_apeglm <- lfcShrink(dge.res, 
                                coef="purpose_treatment_vs_control", 
                                type="apeglm",
                                lfcThreshold=1)
res_tableOE_ashr <- lfcShrink(dge.res, 
                              coef="purpose_treatment_vs_control", 
                              type="ashr",
                              lfcThreshold=1)
```

Beginning with the first row, all shrinkage methods provided by DESeq2 are good for ranking genes by “effect size”, that is the log2 fold change (LFC) across groups, or associated with an interaction term. It is useful to contrast ranking by effect size with ranking by a p-value or adjusted p-value associated with a null hypothesis: while increasing the number of samples will tend to decrease the associated p-value for a gene that is differentially expressed, the estimated effect size or LFC becomes more precise. Also, a gene can have a small p-value although the change in expression is not great, as long as the standard error associated with the estimated LFC is small.

The next two rows point out that apeglm and ashr shrinkage methods help to preserve the size of large LFC, and can be used to compute s-values. These properties are related. As noted in the previous section, the original DESeq2 shrinkage estimator used a Normal distribution, with a scale that adapts to the spread of the observed LFCs. Because the tails of the Normal distribution become thin relatively quickly, it was important when we designed the method that the prior scaling is sensitive to the very largest observed LFCs. As you can read in the DESeq2 paper, under the section, “Empirical prior estimate”, we used the top 5% of the LFCs by absolute value to set the scale of the Normal prior (we later added weighting the quantile by precision). ashr, published in 2016, and apeglm use wide-tailed priors to avoid shrinking large LFCs. While a typical RNA-seq experiment may have many LFCs between -1 and 1, we might consider a LFC of >4 to be very large, as they represent 16-fold increases or decreases in expression. ashr and apeglm can adapt to the scale of the entirety of LFCs, while not over-shrinking the few largest LFCs. The potential for over-shrinking LFC is also why DESeq2’s shrinkage estimator is not recommended for designs with interaction terms.

What are s-values? This quantity proposed by Stephens (2016) gives the estimated rate of false sign among genes with equal or smaller s-value. Stephens (2016) points out they are analogous to the q-value of Storey (2003). The s-value has a desirable property relative to the adjusted p-value or q-value, in that it does not require supposing there to be a set of null genes with LFC = 0 (the most commonly used null hypothesis). Therefore, it can be benchmarked by comparing estimated LFC and s-value to the “true LFC” in a setting where this can be reasonably defined. For these estimated probabilities to be accurate, the scale of the prior needs to match the scale of the distribution of effect sizes, and so the original DESeq2 shrinkage method is not really compatible with computing s-values.

The last four rows explain differences in whether coefficients or contrasts can have shrinkage applied by the various methods. All three methods can use coef with either the name or numeric index from resultsNames(dds) to specify which coefficient to shrink. normal and apeglm also allow for a positive lfcThreshold to be specified, in which case, they will return p-values and adjusted p-values or s-values for the LFC being greater in absolute value than the threshold (see this section for normal). For apeglm, setting a threshold means that the s-values will give the “false sign or small” rate (FSOS) among genes with equal or small s-value. We found FSOS to be a useful description for when the LFC is either the wrong sign or less than the threshold distance from 0.

Finally, normal and ashr can be used with arbitrary specified contrast because normal shrinks multiple coefficients simultaneously (apeglm does not), and because ashr does not estimate a vector of coefficients but models estimated coefficients and their standard errors from upstream methods (here, DESeq2’s MLE). Although apeglm cannot be used with contrast, we note that many designs can be easily rearranged such that what was a contrast becomes its own coefficient. In this case, the dispersion does not have to be estimated again, as the designs are equivalent, up to the meaning of the coefficients. Instead, one need only run nbinomWaldTest to re-estimate MLE coefficients – these are necessary for apeglm – and then run lfcShrink specifying the coefficient of interest in resultsNames(dds).

```{r}
par(mfrow=c(1,4))
plotMA(res_tableOE, ylim=c(-3,3), main = "Unshrinked", cex = .8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)
plotMA(res_tableOE_normal, ylim=c(-3,3), main = "Normal", cex = .8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)
plotMA(res_tableOE_apeglm, ylim=c(-3,3), main = "apeglm", cex = .8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)
plotMA(res_tableOE_ashr, ylim=c(-3,3), main = "ashr", cex = .8)
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```


```{r}
plotCounts(dge.res, gene=which.min(res_tableOE_normal$padj), intgroup="purpose")
```

```{r}
#https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html
df.dge.fit.padj = df.dge.fit %>%
  mutate(padj = res_tableOE_normal$padj) %>%
  arrange(padj) %>% 
  filter(!is.infinite(log.pvalue))

df.deg.upreg = df.dge.fit.padj %>%
  filter(log.pvalue>-log10(0.01)& fold.change>=log2(2))
  
df.dge.downreg = df.dge.fit.padj %>%
  filter(log.pvalue>-log10(0.01) & fold.change<=-log2(2))
```

### KEGG all

```{r}
KEGG_all <- enrichKEGG(gene = df.dge.fit.padj$gene_name,
                        organism = "syn",
                        keyType = "kegg",
                        pvalueCutoff = 0.05,
                        pAdjustMethod ="BH", 
                        minGSSize = 1, 
                        maxGSSize = 5000, 
                        qvalueCutoff = 0.2,
                        use_internal_data = FALSE
                        )
dotplot(KEGG_all,title="KEGG Enrichment Analysis of all Genes")
```

### KEGG upregulated

```{r}
KEGG_upreg <- enrichKEGG(gene = df.deg.upreg$gene_name,
                        organism = "syn",
                        keyType = "kegg",
                        pvalueCutoff = 0.1,
                        pAdjustMethod ="BH", 
                        minGSSize = 1, 
                        maxGSSize = 5000, 
                        qvalueCutoff = 0.2,
                        use_internal_data = FALSE
                        )
dotplot(KEGG_upreg,title="KEGG Enrichment Analysis of all Upregulated Genes")
```

### KEGG downregulated

```{r}
KEGG_downreg <- enrichKEGG(gene = df.dge.downreg$gene_name,
                        organism = "syn",
                        keyType = "kegg",
                        pvalueCutoff = 0.1,
                        pAdjustMethod ="none", 
                        minGSSize = 1, 
                        maxGSSize = 5000, 
                        qvalueCutoff = 0.2,
                        use_internal_data = FALSE
                        )
dotplot(KEGG_downreg, title="KEGG Enrichment Analysis of all Downregulated Genes")
```

### GSEA with KEGG

```{r}
GSEA(
  df.dge.fit.padj$gene_name,
  exponent = 1,
  minGSSize = 1,
  maxGSSize = 500,
  eps = 1e-10,
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  TERM2GENE = NA,
  verbose = TRUE,
  seed = FALSE,
  by = "fgsea"
)
#https://learn.gencore.bio.nyu.edu/rna-seq-analysis/gene-set-enrichment-analysis/
df.genelist.KEGG = df.dge.fit.padj %>%
  select(fold.change, gene_name) %>%
  arrange(desc(fold.change)) %>%
  filter(!is.na(fold.change))

df.genelist.names = df.genelist.KEGG$gene_name
df.genelist.KEGG = df.genelist.KEGG$fold.change
names(df.genelist.KEGG) = df.genelist.names

gseKEGG <- gseKEGG(geneList = df.genelist.KEGG,
               organism     = "syn",
               nPerm        = 10000,
               minGSSize    = 3,
               maxGSSize    = 800,
               pvalueCutoff = 0.1,
               pAdjustMethod = "none",
               keyType       = "kegg")
dotplot(gseKEGG, showCategory = 10, title = "Enriched Pathways" , split=".sign") + facet_grid(.~.sign)
```

```{r}
gseKEGG_emap = enrichplot::pairwise_termsim(gseKEGG)
emapplot(gseKEGG_emap)
```

#The cnetplot depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network (helpful to see which genes are involved in enriched pathways and genes that may belong to multiple annotation categories).

```{r}
cnetplot(gseKEGG, categorySize="pvalue", foldChange=df.genelist.kegg, cex_label_category=0.8, cex_label_gene=0.6, title="KEGG Pathways and Enriched Genes")
```

### GSEA Plot (Absolutely no idea how to read this yet)

```{r}
gseaplot(gseKEGG, by = "all", title = gseKEGG$Description[5], geneSetID = 1)
```

### GSEA with Cyanobase (GO terms)

```{r}
df.cyanobase = ddply(df.go.terms, .(go_term), transform,
                     GO_term = str_c(substr(strsplit(go_term, "GO:", fixed = T)[[1]][2], 1,
                                            nchar(strsplit(go_term, "GO:", fixed = T)[[1]][2])-1),
                                     substr(strsplit(go_term, "GO:", fixed = T)[[1]][1], 1,
                                            nchar(strsplit(go_term, "GO:", fixed = T)[[1]][1])-2),
                                     sep = " ")) %>%
  select(-organism, -go_term)
```

```{r}
df.go.dge = df.cyanobase %>%
  filter(gene_id %in% df.dge.fit$gene_id) %>%
  dplyr::mutate(
    ncbi_id = unlist(lapply(gene_id, function(x){
  df.dge.fit[df.dge.fit$gene_id==x,1][[1]]
      }), use.names = FALSE)
  ) %>%
  select(-gene_id) %>%
  ddply(., .(ncbi_id), transform,
        ncbi_id = strsplit(ncbi_id, "BAA")[[1]][2]) %>%
  group_by(GO_term) %>%
  dplyr::summarise(ncbi_id = list(ncbi_id))

GO.dge = as.list(df.go.dge$ncbi_id)
names(GO.dge) = df.go.dge$GO_term
```

```{r}
go.input = as.matrix(df.dge.DESeq2[,-1])
rownames(go.input) = unlist(lapply(df.dge.DESeq2$gene,
                      function(x){strsplit(x, "BAA")[[1]][2]}),
               use.names = F)

goterms.data = gage(go.input, gsets = GO.dge, ref = 4:6, samp = 1:3)
```

cutoff = numeric, q- or p-value cutoff, between 0 and 1. Default 0.1 (for q-value). When p-value is used, recommended cutoff value is 0.001 for data with more than 2 replicates per condition or 0.01 for les sample sizes.

```{r}
gsea.go.sig<-sigGeneSet(goterms.data, outname="GSEA.Cyanobase(GO)",cutoff = 0.1,
                        heatmap = T, pdf.size = c(7,7))
```

### GO terms. Upregulated.

```{r}
head(goterms.data$greater[, 1:5], 3)

gse.goterm.up = esset.grp(goterms.data$greater, go.input, gsets = GO.dge, 
                          ref = 4:6, samp = 1:3, test4up = T, output = T,
                          outname = "GOterms_Upregulated", make.plot = F)
```

```{r}
gs = unique(unlist(GO.dge[rownames(goterms.data$greater)[1:4]]))
gs_ncbi_id = paste("BAA", GO.dge[[gs]], sep="")
gs_gene_id = df.gene.id[df.gene.id$ncbi_id %in% gs_ncbi_id,]$gene_id

for (gs in rownames(goterms.data$greater)[1:4]) {
  outname = gsub(" |:|/", "_", substr(gs, 9, 100))
  outname = paste(outname, "all", sep=".")
  geneData(genes = GO.dge[[gs]], exprs = go.input, ref = 4:6,
           samp = 1:3, outname = outname, txt = T, heatmap = T,
           Colv = F, Rowv = F, dendrogram = "none", limit = 3, scatterplot = T)
}
```

### GO terms. Downregulated.

```{r}
head(goterms.data$less[, 1:5],3)

gse.goterm.down = esset.grp(goterms.data$less, go.input, gsets = GO.dge, 
                          ref = 4:6, samp = 1:3, test4up = F, output = T,
                          outname = "GOterms_Downregulated", make.plot = F)
```

```{r}
gs = unique(unlist(GO.dge[rownames(goterms.data$less)[1:4]]))

for (gs in rownames(goterms.data$less)[1:4]) {
  outname = gsub(" |:|/", "_", substr(gs, 9, 100))
  outname = paste(outname, "all", sep=".")
  geneData(genes = GO.dge[[gs]], exprs = go.input, ref = 4:6,
           samp = 1:3, outname = outname, txt = T, heatmap = T,
           Colv = F, Rowv = F, dendrogram = "none", limit = 3, scatterplot = T)
}
```

# Proteomics. Protein Analysis.

```{r}
df.proteomics %>%
  dplyr::count(ratio_count) %>%
  ggplot(aes(x = ratio_count, y = n)) +
  geom_bar(stat = "identity") +
  labs(x = "Number of samples", y = "Number of proteins") +
  theme_bw()
```

## Integration with transcriptomics.

```{r}
df.proteomics = ddply(df.proteomics, .(description), transform, 
      gene_id = strsplit(strsplit(description, "[=]")[[1]][4], " ")[[1]][1])
```

```{r}
df.prot.fit = df.proteomics %>%
  filter(gene_id %in%df.dge.fit$gene_name) %>%
  arrange(gene_id)

fold.change.trans = vector(length = nrow(df.prot.fit))
for (i in 1:nrow(df.prot.fit)){
  fold.change.trans[i] = df.dge.fit[df.dge.fit$gene_name==df.prot.fit[i,9],9][[1]]
}

df.prot.fit$transcrip.fc = fold.change.trans
```

```{r}
df.prot.fit %>%
  ggplot(aes(x = avg_ratio, y = transcrip.fc, label = paste(gene_id, protein, sep = "-"))) +
  geom_point() +
  theme_bw() +
  geom_text_repel() +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  labs(x = "Protein effect size: log2(fold-change)", 
       y = "Transcript effect size: log2(fold-change)",
       title = "Log2 ratios correlation between omics.")
```

## GSEA for proteomics. 

```{r}
df.prot.fit.gsea = df.prot.fit %>%
  dplyr::rename(gene_name = gene_id) %>%
  ddply(., .(gene_name), transform, 
        gene_id = df.gene.id[df.gene.id$gene_name==gene_name,3][[1]][1]) %>%
  select(avg_ratio, gene_id) %>%
  arrange(desc(avg_ratio)) %>%
  filter(!is.na(avg_ratio))

df.genelist.names = df.prot.fit.gsea$gene_id
df.genelist.KEGG = df.prot.fit.gsea$avg_ratio
names(df.genelist.KEGG) = df.genelist.names
         
gseKEGG <- gseKEGG(geneList = df.genelist.KEGG,
               organism     = "syn",
               nPerm        = 10000,
               minGSSize    = 3,
               maxGSSize    = 800,
               pvalueCutoff = 0.1,
               pAdjustMethod = "none",
               keyType       = "kegg")
dotplot(gseKEGG, showCategory = 10, title = "Enriched Pathways" , split=".sign") + facet_grid(.~.sign)
```

### G(P)SEA Upregulated.

```{r}
df.genelist.KEGG.up = df.genelist.KEGG[df.genelist.KEGG>1]

gseKEGG <- gseKEGG(geneList = df.genelist.KEGG.up,
               organism     = "syn",
               nPerm        = 10000,
               minGSSize    = 3,
               maxGSSize    = 800,
               pvalueCutoff = 0.1,
               pAdjustMethod = "none",
               keyType       = "kegg")
dotplot(gseKEGG, showCategory = 10, title = "Enriched Pathways" , split=".sign") + facet_grid(.~.sign)
```

### G(P)SEA Downregulated.

```{r}
df.genelist.KEGG.down = sort(df.genelist.KEGG[df.genelist.KEGG<(-1)], decreasing = T)

gseKEGG <- gseKEGG(geneList = df.genelist.KEGG.down,
               organism     = "syn",
               pvalueCutoff = 0.1,
               pAdjustMethod = "none",
               keyType       = "kegg")
dotplot(gseKEGG, showCategory = 10, title = "Enriched Pathways" , split=".sign") + facet_grid(.~.sign)
```








